{"ast":null,"code":"import { __asyncGenerator, __await, __generator } from \"tslib\";\nexport function getChunkedStream(source) {\n  var _a;\n\n  var currentMessageTotalLength = 0;\n  var currentMessagePendingLength = 0;\n  var currentMessage = null;\n  var messageLengthBuffer = null;\n\n  var allocateMessage = function (size) {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    var currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  var iterator = function () {\n    return __asyncGenerator(this, arguments, function () {\n      var sourceIterator, _a, value, done, chunkLength, currentOffset, bytesRemaining, numBytesForTotal, numBytesToWrite;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            sourceIterator = source[Symbol.asyncIterator]();\n            _b.label = 1;\n\n          case 1:\n            if (!true) return [3\n            /*break*/\n            , 16];\n            return [4\n            /*yield*/\n            , __await(sourceIterator.next())];\n\n          case 2:\n            _a = _b.sent(), value = _a.value, done = _a.done;\n            if (!done) return [3\n            /*break*/\n            , 10];\n            if (!!currentMessageTotalLength) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , __await(void 0)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _b.sent()];\n\n          case 4:\n            if (!(currentMessageTotalLength === currentMessagePendingLength)) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , __await(currentMessage)];\n\n          case 5:\n            return [4\n            /*yield*/\n            , _b.sent()];\n\n          case 6:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            throw new Error(\"Truncated event message received.\");\n\n          case 8:\n            return [4\n            /*yield*/\n            , __await(void 0)];\n\n          case 9:\n            return [2\n            /*return*/\n            , _b.sent()];\n\n          case 10:\n            chunkLength = value.length;\n            currentOffset = 0;\n            _b.label = 11;\n\n          case 11:\n            if (!(currentOffset < chunkLength)) return [3\n            /*break*/\n            , 15]; // create new message if necessary\n\n            if (!currentMessage) {\n              bytesRemaining = chunkLength - currentOffset; // prevent edge case where total length spans 2 chunks\n\n              if (!messageLengthBuffer) {\n                messageLengthBuffer = new Uint8Array(4);\n              }\n\n              numBytesForTotal = Math.min(4 - currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer\n              bytesRemaining // bytes left in chunk\n              );\n              messageLengthBuffer.set( // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n              value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n              currentMessagePendingLength += numBytesForTotal;\n              currentOffset += numBytesForTotal;\n\n              if (currentMessagePendingLength < 4) {\n                // not enough information to create the current message\n                return [3\n                /*break*/\n                , 15];\n              }\n\n              allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n              messageLengthBuffer = null;\n            }\n\n            numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, // number of bytes left to complete message\n            chunkLength - currentOffset // number of bytes left in the original chunk\n            );\n            currentMessage.set( // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n            value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesToWrite;\n            currentOffset += numBytesToWrite;\n            if (!(currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength)) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , __await(currentMessage)];\n\n          case 12:\n            // push out the message\n            return [4\n            /*yield*/\n            , _b.sent()];\n\n          case 13:\n            // push out the message\n            _b.sent(); // cleanup\n\n\n            currentMessage = null;\n            currentMessageTotalLength = 0;\n            currentMessagePendingLength = 0;\n            _b.label = 14;\n\n          case 14:\n            return [3\n            /*break*/\n            , 11];\n\n          case 15:\n            return [3\n            /*break*/\n            , 1];\n\n          case 16:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return _a = {}, _a[Symbol.asyncIterator] = iterator, _a;\n}","map":{"version":3,"sources":["c:/work/NodeProjects/hospitaliot/node_modules/@aws-sdk/eventstream-serde-universal/dist/es/getChunkedStream.js"],"names":["__asyncGenerator","__await","__generator","getChunkedStream","source","_a","currentMessageTotalLength","currentMessagePendingLength","currentMessage","messageLengthBuffer","allocateMessage","size","Error","Uint8Array","currentMessageView","DataView","buffer","setUint32","iterator","arguments","sourceIterator","value","done","chunkLength","currentOffset","bytesRemaining","numBytesForTotal","numBytesToWrite","_b","label","Symbol","asyncIterator","next","sent","length","Math","min","set","slice","getUint32"],"mappings":"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","sourcesContent":["import { __asyncGenerator, __await, __generator } from \"tslib\";\nexport function getChunkedStream(source) {\n    var _a;\n    var currentMessageTotalLength = 0;\n    var currentMessagePendingLength = 0;\n    var currentMessage = null;\n    var messageLengthBuffer = null;\n    var allocateMessage = function (size) {\n        if (typeof size !== \"number\") {\n            throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n        }\n        currentMessageTotalLength = size;\n        currentMessagePendingLength = 4;\n        currentMessage = new Uint8Array(size);\n        var currentMessageView = new DataView(currentMessage.buffer);\n        currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n    };\n    var iterator = function () {\n        return __asyncGenerator(this, arguments, function () {\n            var sourceIterator, _a, value, done, chunkLength, currentOffset, bytesRemaining, numBytesForTotal, numBytesToWrite;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        sourceIterator = source[Symbol.asyncIterator]();\n                        _b.label = 1;\n                    case 1:\n                        if (!true) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(sourceIterator.next())];\n                    case 2:\n                        _a = _b.sent(), value = _a.value, done = _a.done;\n                        if (!done) return [3 /*break*/, 10];\n                        if (!!currentMessageTotalLength) return [3 /*break*/, 4];\n                        return [4 /*yield*/, __await(void 0)];\n                    case 3: return [2 /*return*/, _b.sent()];\n                    case 4:\n                        if (!(currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, __await(currentMessage)];\n                    case 5: return [4 /*yield*/, _b.sent()];\n                    case 6:\n                        _b.sent();\n                        return [3 /*break*/, 8];\n                    case 7: throw new Error(\"Truncated event message received.\");\n                    case 8: return [4 /*yield*/, __await(void 0)];\n                    case 9: return [2 /*return*/, _b.sent()];\n                    case 10:\n                        chunkLength = value.length;\n                        currentOffset = 0;\n                        _b.label = 11;\n                    case 11:\n                        if (!(currentOffset < chunkLength)) return [3 /*break*/, 15];\n                        // create new message if necessary\n                        if (!currentMessage) {\n                            bytesRemaining = chunkLength - currentOffset;\n                            // prevent edge case where total length spans 2 chunks\n                            if (!messageLengthBuffer) {\n                                messageLengthBuffer = new Uint8Array(4);\n                            }\n                            numBytesForTotal = Math.min(4 - currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer\n                            bytesRemaining // bytes left in chunk\n                            );\n                            messageLengthBuffer.set(\n                            // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n                            value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n                            currentMessagePendingLength += numBytesForTotal;\n                            currentOffset += numBytesForTotal;\n                            if (currentMessagePendingLength < 4) {\n                                // not enough information to create the current message\n                                return [3 /*break*/, 15];\n                            }\n                            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n                            messageLengthBuffer = null;\n                        }\n                        numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, // number of bytes left to complete message\n                        chunkLength - currentOffset // number of bytes left in the original chunk\n                        );\n                        currentMessage.set(\n                        // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n                        value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n                        currentMessagePendingLength += numBytesToWrite;\n                        currentOffset += numBytesToWrite;\n                        if (!(currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 14];\n                        return [4 /*yield*/, __await(currentMessage)];\n                    case 12: \n                    // push out the message\n                    return [4 /*yield*/, _b.sent()];\n                    case 13:\n                        // push out the message\n                        _b.sent();\n                        // cleanup\n                        currentMessage = null;\n                        currentMessageTotalLength = 0;\n                        currentMessagePendingLength = 0;\n                        _b.label = 14;\n                    case 14: return [3 /*break*/, 11];\n                    case 15: return [3 /*break*/, 1];\n                    case 16: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return _a = {},\n        _a[Symbol.asyncIterator] = iterator,\n        _a;\n}\n"]},"metadata":{},"sourceType":"module"}